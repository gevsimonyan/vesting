// SPDX-License-Identifier: MIT

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "hardhat/console.sol";

contract Vesting is ERC20("VestToken", "VT"), Ownable{
	struct Schedule {
		// holder of tokens after they are released
		address holder;
		// start time of vesting period
		uint256 startTime;
		// delay from startTime when counting time starts 
		uint256 cliff;
		// total amount of vesting periods
		uint256 totalPeriods;
		// time in seconds for every vesting period
		uint256 timePerPeriod;
		// holders vested amount
		uint256 amount;
		// holders claimed funds
		uint256 claimedFunds;
		// schedule initialization marker
		bool initialized;
	}

	event Claimed(address indexed user, uint256 amount);
	event VestingKilled();
	event VestingFunded(address indexed user, uint256 amount);

	// array for all schedules ids
	bytes32[] private vestingSchedulesIds;
	// mapping for all vesting schedules id -> schedule
	mapping(bytes32 => Schedule) private vestingSchedules;
	// mapping user vestings count user.address -> vestings counts
	mapping(address => uint256) private userVestingCount;

	/* solhint-disable no-empty-blocks */
	receive() external payable {}
	fallback() external payable {}
	/* solhint-enable no-empty-blocks */

	/* solhint-disable no-unused-vars */
	function transfer(address _to , uint256 _amount) public override pure returns (bool){
		revert();
	}

	function transferFrom(address _from, address _to, uint256 _amount) public override pure returns (bool) {
		revert();
	}
	/* solhint-enable no-unused-vars */

	/// @notice retunr schedule by id
	/// @param id bytes32 generated by nextSchedulerIdForHolder function
	/// @return a scheduler from vestingSchedules mmapping
	function getVestingSchedule(bytes32 id) public view returns(Schedule memory) {
		return vestingSchedules[id];
	}

	/// @notice retunr user vestings count
	/// @param holder address of user
	/// @return uint256 user vestings count from userVestingCount mapping
	function getUserVestingCount(address holder) public view returns(uint256) {
		return userVestingCount[holder];
	}

	/// @notice return id for generate and accesse user schedulers
	/// @param holder address of user
	/// @param index is index of userVestingCount mapping
	/// @return bytes32 id
	function computeScheduleIdForAddressAndIndex(address holder, uint256 index) public pure returns(bytes32) {
		return keccak256(abi.encodePacked(holder, index));
	}

	/// @notice return id for generate and accesse user schedulers
	/// @param holder address of user
	/// @return bytes32 id
	function nextSchedulerIdForHolder(address holder) public view returns(bytes32) {
		return computeScheduleIdForAddressAndIndex(holder, userVestingCount[holder]);
	}

	/// @notice create vesting schedule and start vesting
	/// @param _holder address of user
	/// @param _cliff delay from block.timestamp when counting time starts
	/// @param _totalPeriods total amount of vesting periods
	/// @param _timePerPeriod time in seconds for every vesting period
	/*  solhint-disable not-rely-on-time */
	function vest(
		address _holder,
		uint256 _cliff,
		uint256 _totalPeriods,
		uint256 _timePerPeriod
	) external payable {
		require(msg.value > 0, "Vesting: You can't vest 0 funds");

		bytes32 id = nextSchedulerIdForHolder(_holder);

		vestingSchedules[id] = Schedule(
			_holder,
			block.timestamp,
			_cliff,
			_totalPeriods,
			_timePerPeriod,
			msg.value,
			0,
			true
		);
		
		userVestingCount[_holder] = userVestingCount[_holder] + 1;
		vestingSchedulesIds.push(id);
		emit VestingFunded(_holder, msg.value);
	}

	/// @notice funtion that allows holder to claim tokens, can called only by reveiver
	/// @param id address of user
	/*  solhint-disable not-rely-on-time */
	function claimFunds(bytes32 id) external {
		Schedule storage schedule = vestingSchedules[id];
		require(msg.sender == schedule.holder, "Vesting: only holder can claim funds");
		require(vestingSchedules[id].initialized == true,"Vesting: Schedule must be initialized");
		require(block.timestamp > schedule.startTime + schedule.cliff, "Vesting: vesting hasn't started yet");
		uint256 passedTime = block.timestamp - (schedule.startTime + schedule.cliff);
		require(passedTime / schedule.timePerPeriod != 0, "Vesting chose another time to claim");
		// must create some other logic, because in some cases(when 0 < passedTime / schedule.timePerPeriod < 1) vesting logic don't work

		uint256 fundsToClaim = schedule.amount / schedule.totalPeriods * (passedTime / schedule.timePerPeriod) - schedule.claimedFunds;

		_mint(schedule.holder, fundsToClaim);
		emit Claimed(schedule.holder, fundsToClaim);
	}
	/*  solhint-enable not-rely-on-time */

	/// @notice funtion that allows holder to withdraw all vested amount, can called only by reveiver
	/// @param id address of user
	function withdraw(bytes32 id, uint256 amount) external {
		Schedule storage schedule = vestingSchedules[id];
		require(msg.sender == schedule.holder, "Vesting: only holder can claim funds");
		require(balanceOf(schedule.holder) >= amount, "Vesting: You can't withdraw more than you have");
		_burn(schedule.holder, amount);
		if (balanceOf(schedule.holder) == 0) {
			schedule.initialized = false;
		}
		payable(schedule.holder).transfer(amount);
	}
}